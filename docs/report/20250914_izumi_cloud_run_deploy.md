# Cloud Run へのデプロイの調査報告書

作成日: 2025年9月14日(日)

## 作成者
- 泉知成

## 調査の全体結論
- Docker Compose は開発環境時に使い、デプロイは Cloud Run で行う。
- バックエンドのAPIサーバーを認証必須 (Require authentication)」に設定し、フロントエンドからのみの通信しか許可しない。
- 開発時とデプロイ時でのエンドポイントのURLをリバースプロキシを挟むことで管理する。

## 1. Cloud Run では Docker Compose が使えない。
前提として、Google Cloud Run は **$PORT にリッスンする単一コンテナ (またはマルチ)** を想定し、Compose のポート/ボリューム定義はそのままでは使えない。
そのため、以下の手順に従って Compose から読み替える必要がある。

- **サービス分割**：`front-app` と `back-server` を Cloud Run の2つのサービスとしてデプロイする。
- **ポート**：アプリ側で 環境変数 `PORT` にリッスンする (Cloud Run が注入)。例えば Node/Flask なら process.env.PORT / os.environ["PORT"] を優先。EXPOSE 3000 等は任意のメタデータで、Cloud Run では効果を持たない。 ￼
- **ヘルスチェック**：Docker の healthcheck は Cloud Run では使われません (不要)。 ￼
- **ボリューム/鍵**：`volumes:` で JSON 鍵を載せる手法は Cloud Run では不可。サービスアカウントをサービスに割り当て (ADC) し、必要な秘密は Secret Manager から注入するか、環境変数に設定する。CI からの認証は OIDC (Workload Identity Federation) を推奨する。

## 2. Docker Compose を使う理由。
セキュリティの関係上、`back-server` (APIを提供) はなるべく外部に公開せず、`front-app` だけを外部に公開したい。
このとき、Docker Compose と ngrok を使えば、docker networksの機能でコンテナ間が通信できるため、back-serverを外部に公開せずとも、front-app だけを などで外部に公開し、frontend と backend は通信が可能という構成が実現できていた。

これを Google Run で実現するには、
- **パターンA：バックエンドを“認証必須”にしてサービス間認証で呼ぶ**
- **パターンB：内部LB＋内部IngressでバックエンドをVPC内だけに限定**
の二つがあるそう。

### パターンA
パターンAでは、バックエンド (back-server) を「認証必須 (Require authentication)」に設定し、Cloud Run Invoker 権限をフロントのサービスアカウントにのみ付与する。
一般ユーザーはトークンを持たないため到達不能になる。

一方、フロント (front-app) は ID トークン を付与してバックエンドの URL にアクセスする (サービス間認証)。

```bash
# バックエンド: 認証必須にする (未認証アクセスを拒否) 
gcloud run services update back-server \
  --region=asia-northeast1 \
  --no-allow-unauthenticated

# フロントの実行SAに「Invoker」を付与
gcloud run services add-iam-policy-binding back-server \
  --region=asia-northeast1 \
  --member=serviceAccount:FRONT_SA@PROJECT_ID.iam.gserviceaccount.com \
  --role=roles/run.invoker
```

```javascript
import {GoogleAuth} from 'google-auth-library';
const target = 'https://back-server-xxxx-asia-northeast1.run.app'; // back-serverのURL
const client = new GoogleAuth().getIdTokenClient(target);
const res = await (await client).request({url: `${target}/api/health`});
```

~~ただし、IAM で遮断しているだけで、URL 自体はインターネット到達可能なため、セキュリティホールなどがあれば外部に見つかってしまう可能性がある。~~

そもそも、「内部だから信用」は危険。
SSRF等でfrontendから内部ネットへ不正リクエストを飛ばされれば意味がない。
URLの検証・固定化、メタデータIPへの到達遮断などのSSRF対策が必要になる。
また、backend側でもトークン認証 (JWT) などをおこなうなどするとよい。

> Server Side Request Forgery (SSRF)  
> SSRFは、例えばクラウド上にある外部に公開されているサーバから、内部のサーバに送られるリクエストを偽造し、本来公開されてないサーバにアクセスするという手法。

### パターンB
バックエンドを「Internal or Internal and Cloud Load Balancing」ingress に設定し、リージョナル内部HTTP(S)LB (serverless NEG バックエンド) 配下に置く。 ￼
- フロントは Direct VPC Egress (または Serverless VPC Access) を有効化し、その 内部LBのプライベートIP に向けて呼び出す。
これにより、パブリック経路を一切通らずに両コンテナ間の通信が可能となる。 ￼

#### 構成
1. back-server を internal 受けに更新。 ￼
1. serverless NEG を作成し、内部 L7 LB (URL マップ／バックエンドサービス) で back-server を紐づけ、内部IP を割り当て。 ￼
1. front-app に Direct VPC Egress (または VPC Access コネクタ) を設定し、内部IP (例：http://10.x.x.x ) へ呼び出し。 ￼

ネットワーク的にも完全非公開だが、LBとVPC周りの追加設定が必要なため、設計はAより重たくなる。

## 3. Google Compute Engine (GCE) という選択肢
[Google Cloud 公式ドキュメント](https://cloud.google.com/appengine/migration-center/run/compare-gae-with-run?hl=ja) からの引用
> **概要**  
>Cloud Run は、 Google Cloud サーバーレスの最新の進化であり、10 年を超える期間にわたって App Engine を実行してきた経験を基盤にしています。Cloud Run は App Engine スタンダード環境とほぼ同じインフラストラクチャで実行されるため、この 2 つのプラットフォームには多くの類似点があります。
>
> Cloud Run は、App Engine のエクスペリエンスを改善するために設計されており、App Engine スタンダード環境と App Engine フレキシブル環境の両方の多くの最良の機能が組み込まれています。Cloud Run サービスは App Engine サービスと同じワークロードを処理できますが、Cloud Run はこれらのサービスをより柔軟に実装できます。この柔軟性に加え、 Google Cloud とサードパーティ サービスの両方の統合により、Cloud Run は App Engine で実行できないワークロードを処理することもできます。

>Cloud Run のリソースモデルは、App Engine と非常に類似していますが、重要な違いがいくつかあります。
>
> - Cloud Run には、最上位の Application リソースや、対応する default サービスがありません。
>- 同じプロジェクト内の Cloud Run サービスは、異なるリージョンにデプロイできます。
> **App Engine では、プロジェクト内のすべてのサービスが同じリージョンにあります。**
> - Cloud Run では、Knative リソースモデルに合わせてバージョンではなくリビジョンという用語を使用します。
> Cloud Run のリビジョン名では `SERVICE_NAME-REVISION_SUFFIX` の形式を使用します。
> ここで、REVISION_SUFFIX は自動生成されるか、`--revision-suffix=REVISION_SUFFIX` デプロイフラグを使用して設定されます。
> - Cloud Run のリビジョンは不変です。つまり、App Engine のバージョンのように `--version=VERSION_ID` デプロイフラグを使用して名前を再利用することはできません。
> - Cloud Run サービス URL は、サービスの最初のデプロイ時に自動的に生成されるサービス ID に基づいています。
> サービス ID の形式は `SERVICE_NAME-<auto-generated identifier>` です。サービス ID は一意であり、サービスの存続期間中は変更されません。
> - Cloud Run では、デフォルトでサービス URL (`SERVICE_IDENTIFIER.run.app` と `https://SERVICE_NAME-PROJECT_NUMBER.REGION.run.app`) のみが公開されます。
> 特定のリビジョンに対処するには、トラフィック タグを構成する必要があります。
> App Engine では、サービスとバージョン URL の両方が自動的に公開されます。

## 4. どうやってAPIのアドレス変えるの？
- フロントは常に /api/* に向け、フロント側でリバースプロキシ (BFF) してバックに転送する構成にすると、開発 (Compose) でも本番 (Cloud Run) でも同じコードで動く。
- ポイントは「ローカルは http://back-server:5000 に素通し」「本番は Cloud Run の back-server に ID トークン付きで転送」。

### 手順
#### 1) 環境変数
- 開発（`.env.local` など）
BACKEND_BASE_URL=`http://back-server:5000`
- 本番（`Doppler/Secret Manager` から注入）
`BACKEND_BASE_URL=https://<back-server-xxxx-<region>.run.app`

#### 2) ルートを丸ごと中継（例：`app/api/[...path]/route.ts`）
```javascript
// app/api/[...path]/route.ts (Next.js 13+ / App Router)
import { NextRequest } from "next/server";

const BASE = process.env.BACKEND_BASE_URL!;

// （本番用）Cloud Run の back-server が「認証必須」の場合、IDトークンを付けて転送
async function fetchWithIdToken(url: string, init: RequestInit) {
  // 本番判定は環境変数で切替（例：NODE_ENVや独自のRUNTIME_ENV）
  if (process.env.RUNTIME_ENV !== "production") return fetch(url, init);

  // ここで only-server の import を使う（ランタイムがNodeのとき）
  const { GoogleAuth } = await import("google-auth-library");
  const client = await new GoogleAuth().getIdTokenClient(BASE);
  // client.request を使って送る（headers や method, body を維持）
  const headers: Record<string, string> = {};
  (init.headers instanceof Headers ? init.headers : new Headers(init.headers || {}))
    .forEach((v, k) => (headers[k] = v));

  const res = await (await client).request({
    url,
    method: init.method,
    headers,
    data: init.body as any,
    // Node fetch と違い、client.request は data を使う
    // 必要なら timeout 等も指定
  });

  return new Response(res.data, {
    status: res.status,
    headers: res.headers as any,
  });
}

export async function GET(req: NextRequest, { params }: { params: { path: string[] } }) {
  const url = `${BASE}/api/${params.path.join("/")}${req.nextUrl.search}`;
  return fetchWithIdToken(url, { method: "GET", headers: req.headers });
}

export async function POST(req: NextRequest, { params }: { params: { path: string[] } }) {
  const url = `${BASE}/api/${params.path.join("/")}${req.nextUrl.search}`;
  const body = await req.arrayBuffer();
  return fetchWithIdToken(url, {
    method: "POST",
    headers: req.headers,
    body: Buffer.from(body),
  });
}

// 他のHTTPメソッド(PUT/PATCH/DELETE等)も同様に実装
```
ブラウザ側の呼び出しは常に fetch('/api/hogehoge') のままでOK。
CORSは同一オリジンになるため不要。

#### 3) Docker Compose（開発時）
- 既存の `front-app` から `http://back-server:5000` へ到達できれば追加設定は不要。
- Next.js を Node ランタイムで動かす場合はコンテナに `google-auth-library` をインストールしておく（本番専用でも可）。

## 5. 結局...
「コンテナを外部に公開していないから安全~♪」ではない。
GCE使った方が、変更箇所少ないから楽ではあるが、Cloud Runはコンテナ1台で1サービスという簡単設計かつ、料金もGCEと比べて安いし、結局APIへのアクセスにIDトークンの認証つけたり将来的にしなくちゃいけないから、Cloud Runでがんばる。うぅ...。

## 参考文献
- [GCP にインスタンスを立てて Docker Compose で動く TLS/SSL 対応の Websocket サーバーにしたい話](https://zenn.dev/socialplus/articles/68d6078dfc1d95)
- [App Engine と Cloud Run の比較](https://cloud.google.com/appengine/migration-center/run/compare-gae-with-run?hl=ja)
- [GCPでdocker-compose.ymlに記述された構成でデプロイする方法](https://teratail.com/questions/317073)
- [CloudRun & Docker 入門](https://zenn.dev/kenken82/articles/cloudrun-docker-tutorial)
- [Next.jsでリバースプロキシーのかわりになるもの](https://qiita.com/k_bobchin/items/5a47ad7e4adacc3a3f95)